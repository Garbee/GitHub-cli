name: Publish To Github Container Registry

on:
  workflow_run:
    workflows: ["Build"]
    types: [completed]

permissions:
  contents: read
  # actions: read       # needed to download artifacts from another run
  packages: write
  id-token: write
  attestations: write

env:
  IMAGE_NAME: github-cli
  OWNER: garbee

jobs:
  publish:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    environment: Development
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Debug list build artifacts (pre-download)
        env:
          RUN_ID: ${{ github.event.workflow_run.id }}
          GH_REPO: ${{ github.repository }}
          TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          echo '::group::Fetch artifact metadata'
          echo "Listing artifacts for run $RUN_ID in $GH_REPO" >&2
          curl -sSL -H "Authorization: Bearer $TOKEN" -H 'Accept: application/vnd.github+json' \
            "https://api.github.com/repos/$GH_REPO/actions/runs/$RUN_ID/artifacts" | tee artifacts.json
          echo 'Raw artifact JSON saved to artifacts.json'
          echo '::endgroup::'

          echo '::group::Artifact names'
          jq -r '.artifacts[]?.name' artifacts.json || true
          echo '::endgroup::'

          count=$(jq '.artifacts|length' artifacts.json || echo 0)
          # Expected artifacts (keep in sync with build matrix)
          required=(build-amd64 build-arm64)
          missing=()
          for r in "${required[@]}"; do
            if ! jq -e --arg n "$r" '.artifacts[]?.name == $n' artifacts.json >/dev/null 2>&1; then
              missing+=("$r")
            fi
          done

          if [ "$count" -eq 0 ] || [ ${#missing[@]} -gt 0 ]; then
            echo '::group::Diagnostics'
            echo "Artifact count: $count" >&2
            echo "Required: ${required[*]}" >&2
            echo "Missing: ${missing[*]:-<none>}" >&2
            echo 'Recent Build run logs may show upload-artifact failures or retention expiration.' >&2
            echo '::endgroup::'

            # Build rich markdown summary
            build_run_url="https://github.com/$GH_REPO/actions/runs/$RUN_ID"
            {
              echo "## ðŸš« Publish Blocked: Missing Build Artifacts";
              echo "**Run ID:** $RUN_ID";
              echo "**Build Run:** [$build_run_url]($build_run_url)";
              echo "**Repository:** $GH_REPO";
              echo "**Found Count:** $count";
              echo "**Required Artifacts:** ${required[*]}";
              if [ ${#missing[@]} -gt 0 ]; then
                echo "**Missing:** ${missing[*]}";
              fi
              echo "### Suggested Actions";
              echo "1. Open the Build workflow for run $RUN_ID and confirm all matrix jobs succeeded.";
              echo "2. Check each job's 'Upload build artifact' step for errors or size limits.";
              echo "3. Ensure the workflow name is exactly 'Build' (case-sensitive) so workflow_run triggers.";
              echo "4. Verify artifacts not expired (retention 2 days) and not manually deleted.";
              echo "5. Re-run the failed Build job if necessary, then re-trigger Publish.";
              echo "### Raw Artifact Names";
              jq -r '.artifacts[]?.name' artifacts.json | sed 's/^/- /' || echo '- <none>';
            } >> "$GITHUB_STEP_SUMMARY"

            if [ "$count" -eq 0 ]; then
              echo "::error title=No Artifacts Found::Build run $RUN_ID produced zero artifacts. Publishing cannot continue." >&2
            else
              echo "::error title=Missing Required Artifacts::Missing: ${missing[*]} (run $RUN_ID)." >&2
            fi
            exit 1
          fi

          echo "All required artifacts present: ${required[*]}"
          build_run_url="https://github.com/$GH_REPO/actions/runs/$RUN_ID"
          {
            echo "## âœ… Build Artifacts Verified";
            echo "**Run ID:** $RUN_ID";
            echo "**Build Run:** [$build_run_url]($build_run_url)";
            echo "**Artifacts Present:** ${required[*]}";
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Set up Buildx (for imagetools)
        uses: docker/setup-buildx-action@v3

      - name: Download artifacts from Build run
        uses: actions/download-artifact@v4
        with:
          path: builds
          run-id: ${{ github.event.workflow_run.id }}

      - name: List downloaded artifacts
        run: |
          find builds -type f -maxdepth 4 -print

      - name: Load per-arch images
        id: load
        run: |
          set -euo pipefail
          base="ghcr.io/${OWNER}/${IMAGE_NAME}"
          images=()
          version=""
          while IFS= read -r tarfile; do
            echo "Loading $tarfile" >&2
            docker load -i "$tarfile" | tee load.out
            # Extract loaded image name (e.g., Loaded image: gh-cli-temp:amd64)
            img=$(awk '/Loaded image:/ {print $3}' load.out | tail -1)
            arch=$(basename "$tarfile" | sed -E 's/.*-([a-z0-9_]+)\.tar$/\1/')
            if [ -f "$(dirname "$tarfile")/image-$arch.txt" ]; then
              v=$(grep '^version=' "$(dirname "$tarfile")/image-$arch.txt" | cut -d= -f2)
              version="$v"
            fi
            new_tag="${base}:build-${{ github.event.workflow_run.id }}-$arch"
            docker tag "$img" "$new_tag"
            images+=("$new_tag")
          done < <(find builds -type f -name 'gh-cli-*.tar' | sort)
          if [ -z "$version" ]; then
            echo "Could not determine version" >&2; exit 1;
          fi
          printf '%s\n' "${images[@]}" > image-list.txt
          echo "version=$version" >> "$GITHUB_OUTPUT"
          echo "Loaded images:"; cat image-list.txt

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ env.OWNER }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push per-arch images
        run: |
          set -euo pipefail
          while IFS= read -r img; do
            echo "Pushing $img"; docker push "$img"; done < image-list.txt

      - name: Create and push manifest tags
        id: manifest
        run: |
          set -euo pipefail
          version='${{ steps.load.outputs.version }}'
          major=$(echo "$version" | cut -d. -f1)
          minor=$(echo "$version" | cut -d. -f1-2)
          base="ghcr.io/${OWNER}/${IMAGE_NAME}"
          tags=("$base:$version" "$base:$minor" "$base:$major" "$base:latest")
          echo 'Assembling manifest from:'
          cat image-list.txt
          create_args=()
          for t in "${tags[@]}"; do
            create_args+=( -t "$t" )
          done
          mapfile -t imgs < image-list.txt
          docker buildx imagetools create "${create_args[@]}" "${imgs[@]}"
          printf 'Published tags:\n'; printf ' - %s\n' "${tags[@]}"
          echo "version=$version" >> "$GITHUB_OUTPUT"

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.5.0

      - name: Sign images with Cosign (keyless)
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          set -euo pipefail
          version='${{ steps.manifest.outputs.version }}'
          base="ghcr.io/${OWNER}/${IMAGE_NAME}"
          major=$(echo "$version" | cut -d. -f1)
          minor=$(echo "$version" | cut -d. -f1-2)
          tags=("$base:$version" "$base:$minor" "$base:$major" "$base:latest")
          echo 'Signing tags:'
          for t in "${tags[@]}"; do
            echo "  -> $t";
            cosign sign --yes "$t";
          done

      - name: Extract digest for provenance (version tag)
        id: digest
        run: |
          set -euo pipefail
          version='${{ steps.manifest.outputs.version }}'
          ref="ghcr.io/${OWNER}/${IMAGE_NAME}:$version"
          echo "Retrieving manifest digest for $ref" >&2
          attempt=0
          digest=""
          while [ $attempt -lt 5 ]; do
            if output=$(docker buildx imagetools inspect "$ref" 2>&1); then
              echo "$output" | sed -n '1,120p'
              digest=$(echo "$output" | awk '/^Digest:/ {print $2; exit}')
              if [ -n "$digest" ]; then
                break
              fi
            else
              echo "imagetools inspect failed (attempt $((attempt+1)))" >&2
              echo "$output" >&2 || true
            fi
            attempt=$((attempt+1))
            echo "Retrying in 3s..." >&2
            sleep 3
          done
          if [ -z "$digest" ]; then
            echo "ERROR: Could not extract digest for $ref after $attempt attempts" >&2
            exit 1
          fi
          echo "digest=$digest" >> "$GITHUB_OUTPUT"
          echo "Digest: $digest"

      - name: Generate and push build provenance
        uses: actions/attest-build-provenance@v1
        with:
          subject-name: ghcr.io/${{ env.OWNER }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.digest.outputs.digest }}
          push-to-registry: true

      - name: Verify signature (latest tag)
        run: |
          set -euo pipefail
          ID_RE="https://github.com/${{ github.repository }}/.github/workflows/.*@.*"
          ISSUER="https://token.actions.githubusercontent.com"
          IMAGE="ghcr.io/${OWNER}/${IMAGE_NAME}:latest"
          echo "Verifying $IMAGE with identity-regexp $ID_RE"
          cosign verify \
            --certificate-identity-regexp "$ID_RE" \
            --certificate-oidc-issuer "$ISSUER" \
            "$IMAGE" || { echo 'Verification failed'; exit 1; }

      - name: Inspect final manifest
        run: |
          docker buildx imagetools inspect ghcr.io/${OWNER}/${IMAGE_NAME}:latest

name: Publish To Github Container Registry

on:
  workflow_run:
    workflows: ["Build"]
    types: [completed]
    branches: [ main ]

permissions:
  contents: read
  actions: read
  packages: write
  id-token: write
  attestations: write

env:
  IMAGE_NAME: github-cli
  OWNER: garbee
  BUILD_RUN_ID: ${{ github.event.workflow_run.id }}
  BUILD_RUN_URL: ${{ format('https://github.com/{0}/actions/runs/{1}', github.repository, github.event.workflow_run.id) }}
  REPO: ${{ github.repository }}

jobs:
  publish:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    environment:
      name: Development
      url: ${{ vars.URL }}
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Download (build-amd64)
        id: dl_amd64
        continue-on-error: true
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5.0.0
        with:
          name: build-amd64
          run-id: ${{ env.BUILD_RUN_ID }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path: builds/build-amd64

      - name: Download (build-arm64)
        id: dl_arm64
        continue-on-error: true
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # 5.0.0
        with:
          name: build-arm64
          run-id: ${{ env.BUILD_RUN_ID }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path: builds/build-arm64

      - name: Validate artifact download
        id: eval_downloads
        run: |
          set -euo pipefail
          a_out='${{ steps.dl_amd64.outcome }}'
          b_out='${{ steps.dl_arm64.outcome }}'
          echo "Validation outcomes: amd64=$a_out arm64=$b_out"
          summary_failed=false
          if [ "$a_out" != "success" ] || [ "$b_out" != "success" ]; then
            summary_failed=true
            {
              echo "## ❌ Artifact Download Validation Failed";
              echo "One or more required artifacts could not be downloaded using the official actions/download-artifact action.";
              echo "**amd64 outcome:** $a_out";
              echo "**arm64 outcome:** $b_out";
              echo "### Likely Causes";
              echo "1. 'actions: read' permission not granted in this publish workflow (currently commented).";
              echo "2. Artifact retention expired or artifact manually deleted.";
              echo "3. Name mismatch (expected: build-amd64, build-arm64).";
              echo "4. Source run belongs to a fork (GITHUB_TOKEN scope differences).";
              echo "### Next Steps";
              echo "- Verify 'actions: read' under permissions and re-run.";
              echo "- Verify artifact names in the Build workflow output.";
              echo "- Confirm artifacts still visible via the UI for run [$BUILD_RUN_ID]($BUILD_RUN_URL).";
            } >> "$GITHUB_STEP_SUMMARY"
            echo "::error title=Artifact Download Validation Failed::Unable to download one or more required artifacts (amd64=$a_out arm64=$b_out)." >&2
          fi
          $summary_failed && exit 1 || echo 'Artifact downloads validated.'

      - name: Set up Buildx (for imagetools)
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3.11.1

      - name: Prepare artifacts for publish (reuse emulation downloads)
        run: |
          set -euo pipefail
          mkdir -p builds
          # Copy files from each emulated download into unified builds dir
          for d in builds/build-*; do
            [ -d "$d" ] || continue
            echo "Staging artifacts from $d" >&2
            cp -a "$d"/. builds/
          done
          echo "Final staged artifact file list:" >&2
          find builds -type f -maxdepth 2 -print | sed 's/^/ - /'

      - name: Load per-arch images
        run: |
          set -euo pipefail
          base="ghcr.io/${OWNER}/${IMAGE_NAME}"
          images=()
          version=""
          while IFS= read -r tarfile; do
            echo "Loading $tarfile" >&2
            docker load -i "$tarfile" | tee load.out
            # Extract loaded image name (e.g., Loaded image: gh-cli-temp:amd64)
            img=$(awk '/Loaded image:/ {print $3}' load.out | tail -1)
            arch=$(basename "$tarfile" | sed -E 's/.*-([a-z0-9_]+)\.tar$/\1/')
            if [ -f "$(dirname "$tarfile")/image-$arch.txt" ]; then
              v=$(grep '^version=' "$(dirname "$tarfile")/image-$arch.txt" | cut -d= -f2)
              version="$v"
            fi
            new_tag="${base}:build-${BUILD_RUN_ID}-$arch"
            docker tag "$img" "$new_tag"
            images+=("$new_tag")
          done < <(find builds -type f -name 'gh-cli-*.tar' | sort)
          if [ -z "$version" ]; then
            echo "Could not determine version" >&2; exit 1;
          fi
          printf '%s\n' "${images[@]}" > image-list.txt
          echo "version=$version" >> "$GITHUB_OUTPUT"
          echo "Loaded images:"; cat image-list.txt

      - name: Log in to GHCR
        uses: docker/login-action@184bdaa0721073962dff0199f1fb9940f07167d1 # v3.5.0
        with:
          registry: ghcr.io
          username: ${{ env.OWNER }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push per-arch images
        run: |
          set -euo pipefail
          while IFS= read -r img; do
            echo "Pushing $img"; docker push "$img"; done < image-list.txt

      - name: Create and push manifest tags
        id: manifest
        run: |
          set -euo pipefail
          # Obtain version by scanning metadata file (more reliable across context limitations)
          meta_file=$(find builds -type f -name 'image-*.txt' | head -1 || true)
          if [ -n "$meta_file" ]; then
            version=$(grep '^version=' "$meta_file" | cut -d= -f2 || true)
          fi
          [ -z "${version:-}" ] && { echo 'Could not resolve version in manifest step'; exit 1; }
          major=$(echo "$version" | cut -d. -f1)
          minor=$(echo "$version" | cut -d. -f1-2)
          base="ghcr.io/${OWNER}/${IMAGE_NAME}"
          tags=("$base:$version" "$base:$minor" "$base:$major" "$base:latest")

          # Extract labels from first loaded arch image for manifest annotations
          first_img=$(head -1 image-list.txt || true)
          title=$(docker image inspect "$first_img" -f '{{ index .Config.Labels "org.opencontainers.image.title"}}' 2>/dev/null || true)
          desc=$(docker image inspect "$first_img" -f '{{ index .Config.Labels "org.opencontainers.image.description"}}' 2>/dev/null || true)
          source=$(docker image inspect "$first_img" -f '{{ index .Config.Labels "org.opencontainers.image.source"}}' 2>/dev/null || true)
          licenses=$(docker image inspect "$first_img" -f '{{ index .Config.Labels "org.opencontainers.image.licenses"}}' 2>/dev/null || true)
          ann_args=()
          add_ann() { [ -n "$2" ] && ann_args+=( --annotation "$1=$2" ); }
          add_ann org.opencontainers.image.title "$title"
          add_ann org.opencontainers.image.description "$desc"
          add_ann org.opencontainers.image.source "$source"
          add_ann org.opencontainers.image.version "$version"
          add_ann org.opencontainers.image.licenses "$licenses"
          if [ ${#ann_args[@]} -eq 0 ]; then
            echo '::warning title=No OCI Annotations Added::No label values discovered for manifest annotations.'
          else
            printf 'Adding manifest annotations:\n'; printf ' - %s\n' "${ann_args[@]}" | sed 's/--annotation //'
          fi
          echo 'Assembling manifest from:'
          cat image-list.txt
          create_args=()
          for t in "${tags[@]}"; do
            create_args+=( -t "$t" )
          done
          mapfile -t imgs < image-list.txt
          docker buildx imagetools create "${create_args[@]}" "${ann_args[@]}" "${imgs[@]}"
          printf 'Published tags:\n'; printf ' - %s\n' "${tags[@]}"
          echo "version=$version" >> "$GITHUB_OUTPUT"

      - name: Install Cosign
        uses: sigstore/cosign-installer@d58896d6a1865668819e1d91763c7751a165e159 # v3.9.2

      - name: Sign images with Cosign (keyless)
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          set -euo pipefail
          version='${{ steps.manifest.outputs.version }}'
          base="ghcr.io/${OWNER}/${IMAGE_NAME}"
          major=$(echo "$version" | cut -d. -f1)
          minor=$(echo "$version" | cut -d. -f1-2)
          tags=("$base:$version" "$base:$minor" "$base:$major" "$base:latest")
          echo 'Signing tags:'
          for t in "${tags[@]}"; do
            echo "  -> $t";
            cosign sign --yes "$t";
          done

      - name: Extract digest for provenance (version tag)
        id: digest
        run: |
          set -euo pipefail
          version='${{ steps.manifest.outputs.version }}'
          ref="ghcr.io/${OWNER}/${IMAGE_NAME}:$version"
          echo "Retrieving manifest digest for $ref" >&2
          attempt=0
          digest=""
          while [ $attempt -lt 5 ]; do
            if output=$(docker buildx imagetools inspect "$ref" 2>&1); then
              echo "$output" | sed -n '1,120p'
              digest=$(echo "$output" | awk '/^Digest:/ {print $2; exit}')
              if [ -n "$digest" ]; then
                break
              fi
            else
              echo "imagetools inspect failed (attempt $((attempt+1)))" >&2
              echo "$output" >&2 || true
            fi
            attempt=$((attempt+1))
            echo "Retrying in 3s..." >&2
            sleep 3
          done
          if [ -z "$digest" ]; then
            echo "ERROR: Could not extract digest for $ref after $attempt attempts" >&2
            exit 1
          fi
          echo "digest=$digest" >> "$GITHUB_OUTPUT"
          echo "Digest: $digest"

      - name: Generate and push build provenance
        uses: actions/attest-build-provenance@977bb373ede98d70efdf65b84cb5f73e068dcc2a # v3.0.0
        with:
          subject-name: ghcr.io/${{ env.OWNER }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.digest.outputs.digest }}
          push-to-registry: true

      - name: Verify signature (latest tag)
        run: |
          set -euo pipefail
          ID_RE="https://github.com/${{ github.repository }}/.github/workflows/.*@.*"
          ISSUER="https://token.actions.githubusercontent.com"
          IMAGE="ghcr.io/${OWNER}/${IMAGE_NAME}:latest"
          echo "Verifying $IMAGE with identity-regexp $ID_RE"
          cosign verify \
            --certificate-identity-regexp "$ID_RE" \
            --certificate-oidc-issuer "$ISSUER" \
            "$IMAGE" || { echo 'Verification failed'; exit 1; }

      - name: Inspect final manifest
        run: |
          docker buildx imagetools inspect ghcr.io/${OWNER}/${IMAGE_NAME}:latest
